<?xml version='1.0' encoding='UTF-8' ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
    <!ENTITY rfc2119 PUBLIC ''
          'http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml'>
]>

<rfc category='std' ipr='trust200902' docName='draft-oauth-binding-v1-00.txt'>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

  <?rfc toc='yes' ?>
  <?rfc tocdepth='3' ?>
  <?rfc symrefs='yes' ?>
  <?rfc sortrefs='yes' ?>
  <?rfc compact='yes' ?>
  <?rfc subcompact='no' ?>
  <?rfc strict='yes' ?>

  <front>

    <title abbrev='OAuth Dynamic Client Binding0'>The OAuth Dynamic Client Binding Protocol</title>

    <author fullname='Christian Scholz' surname='Scholz' initials='C' role='editor'>
      <organization>COM.lounge GmbH</organization>
      <address>
        <email>cs@comlounge.net</email>
        <uri>http://comlounge.net</uri>
      </address>
    </author>
    <author fullname='Eve Maler' surname='Maler' initials='E'>
      <organization>PayPal</organization>
      <address>
        <email>eve@xmlgrrl.com</email>
        <uri>http://www.paypal.com/</uri>
      </address>
    </author>

    <date year='2010' />

    <abstract>
      <t>
        This specification describes the OAuth Dynamic Client Binding protocol.
      </t>
    </abstract>
  </front>

  <middle>

    <section title='Introduction'>
      <t>
        In some scenarios it is necessary to allow OAuth clients to use an authorization 
        server without being known to the server before. Nevertheless for the authorization
        server to work properly and be able to provide the user details about the client 
        requesting authorization, a way of automatic registration is needed.
        
        The goal should be to provide the client with a client id and eventually a client 
        secret from the server and the authorization server with information about the client
        such at minimum with it's name. More likely though more information is necessary
        such as the homepage, icon, description, company etc. 
        
        This informal draft tries to present different ways of achieving this exchange of 
        information.
        
      </t>

      <section title='Notational Conventions'>
        <t>
          The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL NOT', 'SHOULD', 'SHOULD
          NOT', 'RECOMMENDED', 'MAY', and 'OPTIONAL' in this document are to be interpreted as
          described in <xref target='RFC2119' />.
        </t>
        <t>
          This document uses the Augmented Backus-Naur Form (ABNF) notation of
          <xref target='I-D.ietf-httpbis-p1-messaging' />. Additionally, the realm and auth-param
          rules are included from <xref target='RFC2617' />.
        </t>
        <t>
          Unless otherwise noted, all the protocol parameter names and values are case sensitive.
        </t>
      </section>

      <section title='Terminology'>
        <t>
          <list style='hanging' hangIndent='6'>
            <t hangText='resource server'>
              <vspace />
              A server capable of accepting and responding to protected resource requests.
            </t>
            <t hangText='client'>
              <vspace />
              An application obtaining authorization and making protected resource requests.
            </t>
            <t hangText='authorization server'>
              <vspace />
              A server capable of issuing tokens after successfully authenticating the resource
              owner and obtaining authorization. The authorization server may be the same server as
              the resource server, or a separate entity.
            </t>
            <t hangText='end-user authorization endpoint'>
              <vspace />
              The authorization server's HTTP endpoint capable of authenticating the end-user and
              obtaining authorization. 
            </t>
            <t hangText='token endpoint'>
              <vspace />
              The authorization server's HTTP endpoint capable of issuing tokens and refreshing
              expired tokens. 
            </t>
            <t hangText='client identifier'>
              <vspace />
              An unique identifier issued to the client to identify itself to the authorization
              server. Client identifiers may have a matching secret. 
            </t>
          </list>
        </t>
      </section>
      <section title='Requirements'>
        <t>
          <list style='hanging' hangIndent='6'>
	    <t hangText='The client needs to be uniquely identifiable by the authorization server'>
		<vspace />
		In order for an authorization server to do proper user delegated authorization it must be able to identify clients in order to prevent
		unauthorized access, e.g. if just a client name is given.
		Like today the client credentials should thus be provided by the authorization server and not proposed by the client.
	    </t>
	    <t hangText='The authorization server must be able to retrieve metadata about a client for later user interaction'>
		<vspace />
		In order for the authorization server to describe a client to the user in the authorization step it needs information about the client. This
		can be the client name at a minimum but today servers usually request at least a description, a homepage URL and an icon when doing manual
		registration.
	    </t>
	    <t hangText='The authorization server must have the option of strongly authenticating the client and its metadata'>
		<vspace />
		In order to prevent spoofing of clients the authorization server should have the option to verify the provided information to check if it's valid.
		This might be solved using certificates or in a simpler way by pulling from the client URL e.g. via hostmeta discovery.
	    </t>
	    <t hangText='Automatic client binding must also be possible from applications running on mobile devices'>
		<vspace />
		Information cannot be pushed to mobile devices, so the two solutions are providing information in a response to a push and doing polling. The latter
		is not resource friendly though.
	    </t>
	    <t hangText='Data integrity must be ensured in large deployments where data propagation can be an issue'>
		<vspace />
		When e.g. pushing information from a client to a server endpoint it might take a certain amount of time for this data to propagate through
		big installation over various data centers. Care needs to be taken that subsequent actions after the registration process like an authorization
		request show the correct data. 
		(how would a pull look like here as it's always the client which needs to start the process)
	    </t>
          </list>
       </t>

          
      </section>
      <section title="Binding Flows">
	<t>
	    There are different approaches one can take to exchange client information with client credentials. 
	</t>
	<section title="Providing client information on every request and not using client credentials at all.">
	    <t>
		In this approach all necessary client information like client_name or client_icon is passed on every request to the authorization
		server to display it to the user if necessary. 
	    </t>
	    <t>
		This violates the first requirement though. No client credentials are actually provided which also violates the OAuth 
		specification as it is now.
	    </t>
	</section>
	<section title="The client pushes client information to the authorization server which returns client credentials">
	    <t>
		The client discovers the registration endpoint of the authorization server and sends it's client information to that endpoint in JSON format.
		The authorization server answers with client credentials in the response.
	    </t>
	    <t>
		Authorization is possible here as the client information could be signed with the clients secret key and could contain a URL to the
		client homepage which could contain a discoverable public key. This involves PKI though which is hard to implement. 
	    </t>
	    <t>
		Moreover it might violate the propagation requirement as the information might be pushed to a server far away from the server
		the user gets send to in the next step which migth not know the client credentials yet.
	    </t>
	</section>

	<section title="The authorization server pulls information from the client and returns client credentials">
	    <t>
		In this version the client sends a URL to the authorization server which then uses that information to pull metadata about the client
		e.g. via XRD. It then will create client credentials and return them in the response to the initial request.
	    </t>	
	    <t>
	    This does not directly solve the propagation issue as it's still a push to some server of the authorization server cluster and not bound
	    to the user interaction.
	    </t>
	</section>

    </section>
    
    <section title='Security Considerations'>
      <t>
      </t>
    </section>

    <appendix title='Examples'>
      <t>
        [[ todo ]]
      </t>
    </appendix>

    <appendix title='Contributors'>
      <t>
        The following people contributed to preliminary versions of this document:
      </t>
      <t>
        The User Managed Access Working Group has dozens of very active contributors who
        proposed ideas and wording for this document, including: [[ If your name is
        missing or you think someone should be added here, please send Eran a note - don't
        be shy ]]
      </t>
      <t>
        [[Â todo ]]
      </t>
    </appendix>

    <appendix title='Acknowledgements'>
      <t>
        [[ Add OAuth 2.0 authors + WG contributors ]]
      </t>
    </appendix>

    <appendix title='Document History'>
      <t>
        [[ to be removed by RFC editor before publication as an RFC ]]
      </t>
      <t>
        -01
        
        <list style='symbols'>
          <t>
            started the spec.
          </t>
        </list>
      </t>
    </appendix>

  </middle>

  <back>

    <references title='Normative References'>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2617.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml3/reference.I-D.draft-ietf-httpbis-p1-messaging-09.xml'?>
<!--
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2045.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2104.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2616.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.2818.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.3023.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.3447.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.3629.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.4627.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml/reference.RFC.5246.xml' ?>
      <?rfc include='http://xml.resource.org/public/rfc/bibxml4/reference.W3C.REC-html401-19991224.xml' ?>
-->

    </references>

  </back>

</rfc>
